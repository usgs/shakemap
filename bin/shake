#!/usr/bin/env python

# stdlib imports
import os.path
import argparse
import sys
import traceback
import io
import socket
import pkgutil
import inspect
import importlib
import time
from collections import OrderedDict
from configobj import ConfigObj

import matplotlib
matplotlib.use('Agg')

# local imports
from shakemap.utils.config import get_config_paths
from shakemap.utils.config import get_logger


def _get_config():
    """
    Read the config file and return the resulting structure.
    """
    install_path, data_path = get_config_paths()
    config_file = os.path.join(install_path, 'config', 'shake.conf')
    config = ConfigObj(config_file)
    return config


def _get_command_classes(config):
    """
    Create a dictionary of classname:class to be used in main().

    Returns:
        dict: Dictionary of classname:class where each class
            is a subclass of shakemap.coremods.base.CoreModule.
    """
    coremods = {}
    for modname in config['coremods']:
        mod = importlib.import_module(modname)
        cm = {
            name: importlib.import_module(name)
            for finder, name, ispkg
            in pkgutil.iter_modules(mod.__path__, mod.__name__ + ".")
        }
        coremods.update(cm)

    classes = {}
    for name, module in coremods.items():
        for m in inspect.getmembers(module, inspect.isclass):
            if m[1].__module__ == name:
                core_class = getattr(module, m[0])
                if not hasattr(core_class, 'command_name'):
                    continue
                cmd = core_class.command_name

                if not cmd:
                    continue
                classes[cmd] = core_class

    ordered_classes = OrderedDict()
    keys = sorted(classes.keys())
    for k in keys:
        ordered_classes[k] = classes[k]

    return ordered_classes


_config_ = _get_config()
_classes_ = _get_command_classes(_config_)


def _format_error_info(exception, eventid):
    """
    Format exception information and stack trace into a coherent multi-line
    string.

    Args:
        exception (Exception): Python Exception (or child thereof) instance.
        eventid (str): ShakeMap event ID (i.e., us2018abcd).
    Returns:
        str: Multiline string containing: Hostname,eventid,Exception string,
             and stack trace.

    """
    stringio = io.StringIO()
    ex_type, ex, tb = sys.exc_info()
    traceback.print_tb(tb, file=stringio)
    stack_trace = stringio.getvalue()
    stringio.close()
    hostname = socket.gethostname()
    fmt = '\nHost: %s\nEvent ID: %s\nException: %s\nStack Trace: %s'
    error_msg = fmt % (hostname, eventid, str(exception), stack_trace)
    return error_msg


def get_parser():
    """
    Internal method to get argparse parser instance.

    Returns:
        ArgumentParser: argparse argument parser.
    """
    description = '''
    Run specified ShakeMap modules.
    '''

    epilog = 'Available modules:\n'
    for key, core_class in _classes_.items():
        if key.startswith('xtest'):
            continue
        epilog += '    - %s\n' % inspect.getdoc(core_class)

    epilog += '\nUse "shake help command" to see the options for a '\
              'specific command.\n'

    parser = argparse.ArgumentParser(
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('eventid',
                        help='The id of the event to process.')
    parser.add_argument('cmds', nargs=argparse.REMAINDER,
                        help='The modules to run.')
    parser.add_argument('-d', '--debug', action='store_true',
                        help='Print all informational messages.')
    parser.add_argument('-q', '--quiet', action='store_true',
                        help='Print only errors.')
    parser.add_argument('-l', '--log', action='store_true',
                        help='Log all output.')
    return parser


def main(args):
    """
    Loop over input commands and call module.execute() for each matching
    command.

    Args:
        ArgumentParser: argparse argument parser.


    """
    install_path, data_path = get_config_paths()
    log_option = None
    if args.debug:
        log_option = 'debug'
    if args.quiet:
        log_option = 'quiet'
    if args.log:
        log_option = 'log'

    logger = get_logger(args.eventid, log_option=log_option)

    try:
        cmd_list = OrderedDict()
        arglist = args.cmds.copy()
        oldcmd = ''
        while(len(arglist) > 0):
            cmd = arglist.pop(0)

            if cmd.startswith('-'):
                raise KeyError('Command "%s" cannot process option "%s"' %
                               (oldcmd, cmd))

            if cmd not in _classes_:
                raise KeyError('Command "%s" not found in ShakeMap.' % cmd)

            cmd_class = _classes_[cmd]
            cmd_obj = cmd_class(args.eventid)
            cmd_list[cmd] = cmd_obj

            if args.eventid.lower() == 'help':
                arglist = ['-h']

            arglist = cmd_obj.parseArgs(arglist)
            oldcmd = cmd

        for cmd, obj in cmd_list.items():
            logger.info('Running command %s' % cmd)
            t1 = time.time()
            obj.execute()
            t2 = time.time()
            elapsed = t2 - t1
            logger.info('Finished running command %s: Elapsed %.2f secs'
                        % (cmd, elapsed))
            # create/update the contents.xml file
            obj.writeContents()

    except Exception as e:
        error_msg = _format_error_info(e, args.eventid)
        logger.error(error_msg)  # should get sent by email and logged
        sys.exit(1)


if __name__ == '__main__':
    parser = get_parser()
    pargs = parser.parse_args()
    if pargs.eventid.lower() == 'help' and len(pargs.cmds) == 0:
        parser.print_help()
    else:
        main(pargs)
    sys.exit(0)
